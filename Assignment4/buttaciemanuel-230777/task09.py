# -*- coding: utf-8 -*-
"""Task09.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aA_7cDJnS46kKnLS5uuCGN5_s3QANqk-

**Task 09: Data linking**
"""

github_storage = "https://raw.githubusercontent.com/FacultadInformatica-LinkedData/Curso2020-2021/master/Assignment4/"

from rdflib import Graph, Namespace, Literal, URIRef
from rdflib.namespace import OWL
from rdflib.plugins.sparql import prepareQuery

datans1 = Namespace('http://data.three.org#')
datans2 = Namespace('http://data.four.org#')
vcard = Namespace('http://www.w3.org/2001/vcard-rdf/3.0#')

g1 = Graph()
g2 = Graph()
g3 = Graph()

g1.parse(github_storage+"resources/data03.rdf", format="xml")
g2.parse(github_storage+"resources/data04.rdf", format="xml")

"""Busca individuos en los dos grafos y enlázalos mediante la propiedad OWL:sameAs, inserta estas coincidencias en g3. Consideramos dos individuos iguales si tienen el mismo apodo y nombre de familia. Ten en cuenta que las URI no tienen por qué ser iguales para un mismo individuo en los dos grafos."""

# for each couple (fullname, family) we have the list of identifiers found in both graphs in order to establish then a
# linear matching algorithm
links: dict[tuple[str, str], list[URIRef]] = {}
# query for retrieving people metadata is the same in both
text = '''
    SELECT ?Identifier ?Name ?Family WHERE {
        ?Identifier a datans:Person .
        ?Identifier vcard:FN ?Name .
        ?Identifier vcard:Family ?Family .
    }
'''
# binds with respective namespaces for each graph
query1 = prepareQuery(text, initNs = { 'vcard': vcard, 'datans': datans1 })
query2 = prepareQuery(text, initNs = { 'vcard': vcard, 'datans': datans2 })
# extracts identifiers associated to each (fullname, family) in first graph
for r in g1.query(query1):
    key = (r.Name, r.Family)
    links.setdefault(key, [])
    links[key].append(r.Identifier)
# extracts identifiers associated to each (fullname, family) in second graph
for r in g2.query(query2):
    key = (r.Name, r.Family)
    links.setdefault(key, [])
    links[key].append(r.Identifier)
# if for each couple (fullname, family) we have an identifier from both g1 and g2, then a link can be established
for identifiers in links.values():
    if len(identifiers) > 1:
        g3.add((identifiers[0], OWL.sameAs, identifiers[1]))
# display g3
for s, o, p in g3:
    print(s, o, p)